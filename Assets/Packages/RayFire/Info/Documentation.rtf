{\rtf1\ansi\ansicpg1252\deff0{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Consolas;}{\f2\fnil\fcharset0 Consolas;}{\f3\fnil\fcharset204 Consolas;}{\f4\fnil Calibri;}{\f5\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue0;\red208\green208\blue208;\red189\green189\blue189;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\qc\lang9\ul\b\f0\fs56 RayFire for Unity 1.15\par
Documentation \fs48\par
\pard\ri-22\sl276\slmult1\tx8662\tx8946\ulnone\b0\fs28\par
=============================================================\par
\pard\sl276\slmult1\qc\ul\b\fs56\par
RayFire Man component\fs36\par
\pard\sl276\slmult1\ulnone\b0\fs22\par
RayFireMan script works as a manager for all simulated objects. You can create it and setup your own properties. it will be created automatically and use default properties if you didn't created it before.\par
\pard\sl276\slmult1\qc\par
\pard\sl276\slmult1\lang1033\b\fs48\tab Gravity \fs28\par
\fs22\par
Set gravity\b0 : \lang9 Enables custom gravity multiplier.\lang1033\par
\par
\b Multiplier\b0 : \lang9 Multiplier for gravity force.\par
\par
\pard\sl276\slmult1\qc\lang1033\fs28\tab\par
\pard\sl276\slmult1\b\fs48\tab Infinite Fall\par
\fs22\par
Destroy\b0 : Allows to destroy simulated objects if they fall too far from their original position.\par
\par
\b Distance\b0 : Defines maximum distance over Y axis between original and current position.\par
\par
\pard\sl276\slmult1\qc\fs28\par
\pard\sl276\slmult1\b\fs48\tab Materials\fs56\par
\b0\fs22\par
\b Minimum Mass\b0 : Minimum mass for rigid body.\par
\b Maximum Mass\b0 : Maximum mass for rigid body.\par
\lang9\fs44\par
Material Presets\lang1033\b\fs22\par
\par
Destructible\b0 : Object will be possible to demolish only if Destructible state is On.\par
\b Solidity\b0 : Material Solidity multiplier. Decreae to make objects more fragile.\par
\b\par
Density\b0 : Defines object mass by it's volume. \par
\b Drag\b0 : Defines\par
\b Angular Drag\b0 : Defines\par
\par
\b Material\b0 : Defines\par
\b Dynamic Friction\b0 : Defines\par
\b Static Friction\b0 : Defines\par
\b Bounciness\b0 : Defines\fs28\par
\par
\b\fs56\tab\fs48 Demolition\fs28\par
\fs22\par
Global Solidity\b0 : \lang9 Global solidity multiplier for all RayFireRigid scripts. \par
\par
\lang1033\b Time Quota\b0 : \lang9 Defines allows time pre frame for single demolition. If Object was demolished and it took more time than this value then no more demolitions will be allowed at this frame.\par
\par
\fs44 Advanced Demolition Properties\lang1033\b\fs22\par
\par
\lang9\fs28\tab Post Demolition\b0\fs32\par
\lang1033\b\fs22\par
Demolished Object\b0 :\lang9  Defines what will happen with demolished object.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\lang1033\b Deactivate\b0 :\lang9  Object will be deactivated and stay in scene.\par
\lang1033\b{\pntext\f5\'B7\tab}Destroy\b0 :\lang9  Object will be deactivated and destroyed after \b Destroy Delay \b0 time.\par
\pard\sl276\slmult1\par
\b Destroy Delay\lang1033\b0 :\lang9  Deactivated demolished object wull stay in scene this time and then will be destroyed.\par
\par
\par
\b\fs28\tab Fragments\b0\fs22\par
\par
\lang1033\b Parent\b0 :\lang9  Defines parent for demolition fragments.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\lang1033\b Manager\b0 :\lang9  Fragments will use Manager'g gameobject as parent.\par
\lang1033\b{\pntext\f5\'B7\tab}Parent\b0 :\lang9  Fragments will use original object as parent.\par
\pard\sl276\slmult1\lang1033\b\par
Maximum Amount\b0 :\lang9  O\lang1033 bject will not be demolished if  current amount of all new created fragments is more than \b Maximum Amount\b0 , you can see current \b fragments amount \b0 value on top of RayFireMan component\lang9 .\par
\lang1033\b\par
Bad Mesh Try\b0 : \lang9 Defines amount of attempts to demolish object. During demolition object can be marked as "Bad Mesh" in case it's mesh was impossible to fragment for some reason. If mesh was defined as "Bad" at Input step - it always will be marked as "Bad" at Input step. If object was fragmented but some of it's fragments has some problem with mesh it also will be marked as "Bad Mesh", but with different fragmentation properties it still could be fragmented with no problems. Using \lang1033\b Bad Mesh Try\b0  \lang9 property you can define how many times object will try to fragment itself before it will be marked as "Undemolishable". After this it will not try to demolish itself anymore. \par
\lang1033\par
\lang9\par
\b\fs28\tab Shadow Casting\par
\lang1033\fs22\par
Size Threshold\b0 :\lang9  Objects with bounding size less than this will not cast shadows.\par
\lang1033\par
\fs28\tab\par
\b\fs48\tab Fragment pooling\par
\fs22\par
Enable Pooling\b0 : \lang9 Enables fragment pooling  to decrease demolition time. Demolished object creates new gameobject for every fragment, after this it has to add all necessary components to it. Using pooling you can prevent this, in this case there always will be some amount of gameobjects with all components and Demolished object will need only to take it and apply mesh data and other Rigid properties. After this pool will restore amount of "dummy" fragments. It is especially useful when you use Precache demolition type with high amount of precached meshes.\par
\lang1033\par
\b Pool Limit\b0 : \lang9 Defines amount "dummy" fragments.\par
\par
\par
\fs28 ===========================================================\par
\fs22\par
\par
\pard\sl276\slmult1\qc\ul\b\fs56 RayFire Rigid component\ulnone\fs22\par
\pard\sl276\slmult1\b0\par
It's main purpose is \b Advanced Physics Control\b0  and \b Runtime Demolitions\b0 . Using Rigid component you can demolish 3d objects into thousands fragments and every fragment can be demolished further deeper and deeper.\par
\b\fs32\par
\fs22 Initialization\lang1033\b0 : Defines when object will be initialized. Initialization adds all necessary components to object, setup them accordingly to properties and start necessary coroutines.\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/-wW9OfnhIh0"}}{\fldrslt{\ul\cf1 https://youtu.be/-wW9OfnhIh0}}}\b0\f0\fs22\par
\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b By Method\b0 : Object will be initialized by \i Initialize() \i0 method. This is default initialization type. In this way you can add Rigid component to objects in your code and they will not be initialized unless you will Initialize them as well. Object with ByMethod type can be initialized in Editor using Initialize button on top of Rigid component.\par
\b{\pntext\f5\'B7\tab}At Start\b0 : Object will be initialized at Start.\par
\pard\li360\sl276\slmult1\par
\pard\sl276\slmult1\lang9 Object can be initialized using method:\lang1033\par
\cf1\f1\fs19 public\cf2  \cf1 void\cf2  \f2 Initialize\f1 ()\cf0\f0\fs22\par
\lang9\fs28\tab\par
\b\fs48\tab Main\par
\fs32\par
\fs22 Simulation Type\lang1033\b0 : Defines behavior of object during simulation.\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/KZ8h9F45lkM"}}{\fldrslt{\ul\cf1 https://youtu.be/KZ8h9F45lkM}}}\b0\f0\fs22\par
\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b Dynamic\b0 : Object will be affected by gravity, will start fall down and it will be possible to affect on it by other simulated objects. \par
\b{\pntext\f5\'B7\tab}Sleeping\b0 : Object will freeze in air until first collision with any other object, then it will start behave as Dynamic object.\par
\b{\pntext\f5\'B7\tab}Inactive\b0 : Object will freeze in air and will not be affected by gravity, it can be affected by other simulated objects but it will not start fall down until it will be activated. After activation object will start behave like Dynamic object.\par
\b{\pntext\f5\'B7\tab}Kinematic\b0 : Object will use it's animation to affect to other objects but it will not be affected anyhow by any other object. Can use actual mesh as collider.\par
\b{\pntext\f5\'B7\tab}Static\b0 : Object will not be moved from it's position, it will interact with Dynamic objects but it will not be affected anyhow by any other object. Can use actual mesh as collider.\par
\pard\sl276\slmult1\lang9\b\par
\pard\sl276\slmult1\qc ***\par
\pard\sl276\slmult1\par
Object Type\lang1033\b0 : Rigid component can simulate single object using it's mesh for simulation, but also it can simulate multiple objects as one concave object using all children meshes.\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/fbVG1Y0RoBY"}}{\fldrslt{\ul\cf1 https://youtu.be/fbVG1Y0RoBY}}}\lang1033\b0\f0\fs22\par
\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b Mesh\b0 : Simulate object using it's Meshfilter's mesh in Mesh Collider.\par
\b{\pntext\f5\'B7\tab}Mesh Root\b0 : Should be added to empty root with children with meshes. Add same Rigid component to all children and simulate them as \b Mesh \b0 type. Root itself is not going to be simulated. Using this type you don't need to select every children to add Rigid components or to edit them later, you only need to edit all properties for Root.\par
\b{\pntext\f5\'B7\tab}Skinned Mesh\b0 : Demolishes Skinned mesh object.\par
\b{\pntext\f5\'B7\tab}Nested Cluster\b0 : Simulated object using all it's children Meshfilter's meshes as one solid concave object. In this case root will get Mesh Collider for every child with it's mesh. To Create such object you need to add Rigid component to root which has all objects which you want to simulate as solid object as it's children. In case of demolition Cluster will detach every child and start simulate them on their own. If child is also just a root for other children with meshes after demolition it will be considered as Nested Cluster as well. In this way you can demolish object in your own way.\par
\b{\pntext\f5\'B7\tab}Connected Cluster\b0 : Simulated object using all it's children Meshfilter's meshes as one solid concave object like Nested Cluster. It uses only children from first layer, nesting is not allowed.  During demolition it will detach fragments at contact point while the rest of the fragments will stay as solid cluster. At every demolition cluster checks itself for connectivity and if it detects that some groups of fragments are not connected together anymore they will start simulate as separate Connected Clusters.\par
\pard\sl276\slmult1\lang9\b\par
\pard\sl276\slmult1\qc ***\par
\pard\li360\sl276\slmult1\lang1033\b0\par
\pard\sl276\slmult1\lang9\b Demolition Type\b0 : \lang1033 Define when and how object will be demolished during Play mode. \par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/_aO08dcqBOQ"}}{\fldrslt{\ul\cf1 https://youtu.be/_aO08dcqBOQ}}}\b0\f0\fs22\par
\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b None\b0 : Object will not be demolished.\lang9\b\fs32\par
\lang1033\fs22{\pntext\f5\'B7\tab}Runtime\b0 : Object will be demolished in Runtime. Fragments will be created at collision contact moment. It is better to use this type for low poly objects with low Fragments \b Amount \b0 value. Slowest speed among other types.\lang9\b\fs32\par
\lang1033\fs22{\pntext\f5\'B7\tab}Awake Precache\b0 : Object will precached all fragments mesh data in Awake and store all mesh data info in Rigid component. At collision contact gameobjects with all necessary components will be created and mesh will be assigned. \lang9\b\fs32\par
\lang1033\fs22{\pntext\f5\'B7\tab}Awake Prefragment\b0 : Object will be prefragmented in Awake. All fragments will be disabled and waiting for demolition. \lang9\b\fs32\par
\lang1033\fs22{\pntext\f5\'B7\tab}Manual Prefab Precache\b0 : Special type if you want to manually precache mesh data in prefab and save it as asset in project folder. Regular Precache type can not store mesh data as assets because Unity Mesh is not serializable. Precached Prefab stores mesh data in serializable format way which allows to store it as asset. \lang9\b\fs32\par
\lang1033\fs22{\pntext\f5\'B7\tab}Manual Precache\b0 : Allows to manually precache all fragments meshes in Editor and use  precached meshes for fragments. In this case it will not waste time in Awake to cache mesh data for fragments. Do not use this type if you want to create prefab, prefab can not store Unity mesh data, use \b Manual Prefab Precache \b0 instead.\lang9\b\fs32\par
\lang1033\fs22{\pntext\f5\'B7\tab}Manual Prefragment\b0 : Allows to manually prefragment object in Editor. In this case it will not waste time in Awake to prefragment object.\lang9\b\fs32\par
\lang1033\fs22{\pntext\f5\'B7\tab}Reference Demolition\b0 : Allows to swap demolished object to predefined reference and demolish instance of this reference instead. Reference object could be FBX asset, prefab or other scene object.\lang9\b\fs32\par
\pard\sl276\slmult1\qc\par
\pard\sl276\slmult1\fs48\tab Simulation\par
\lang1033\b0\fs22\par
\lang9\fs44 Physics\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/MxMaPZLpLto"}}{\fldrslt{\ul\cf1 https://youtu.be/MxMaPZLpLto}}}\lang1033\b0\f0\fs44\par
\lang9\fs28\par
\b\tab Physic Material\b0\fs32\par
\lang1033\b\fs22\par
Material Type\b0 : Material preset with predefined density, friction, elasticity and solidity. Can be edited in Rayfire Man component.\par
\par
\b Material\b0 : Allows to define define own \b Physic Material.\b0  Keep in mind that it still will use define \b Material Type\b0  for \b Solidity \b0 and \b Mass\b0 .\par
\par
\lang9\b\fs28\tab Mass\b0\fs32\par
\lang1033\b\fs22\par
Mass By\b0 : Allows to choose the way Mass will be applied to RigidBody component.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\lang9\b Material Density\b0 : \lang1033 Object will get mass accordingly to defined \b Material Type \b0 and mesh volume.\par
\lang9\b{\pntext\f5\'B7\tab}Mass Property\b0 : \lang1033 Object will get mass by Mass property\par
\pard\sl276\slmult1\b Mass\b0 : RigidBody component will get this value if \b Mass By\b0  set to \lang9\b Mass Property.\lang1033\b0\par
\b\par
\lang9\fs28\tab Collider\b0\fs32\par
\lang1033\b\fs22\par
Collider Type\b0 : Allows to choose automatic collider type for object if object has no custom collider applied.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\lang9\b Mesh\b0 : \lang1033 Object will get Mesh Collider.\par
\lang9\b{\pntext\f5\'B7\tab}Sphere\b0 : \lang1033 Object will Sphere Collider\par
\lang9\b{\pntext\f5\'B7\tab}Box\b0 : \lang1033 Object will get Box Collider.\par
\lang9\b{\pntext\f5\'B7\tab}None\b0 : \lang1033 Object will not get automatic collider.\par
\pard\sl276\slmult1\par
\lang9\fs28\tab\par
\i\fs44 Activation\i0\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/t8JbxKyP91Y"}}{\fldrslt{\ul\cf1 https://youtu.be/t8JbxKyP91Y}}}\b0\f0\fs22\par
\par
Inactive object can be activated using public method:\lang1033\par
\cf1\f1\fs19 public\cf2  \cf1 void\cf2  Activate()\cf0\lang9\f0\fs44\par
\lang1033\fs22\par
\pard\sl276\slmult1\lang9\b By Velocity\b0 : \lang1033 Inactive object will be activated when it's velocity will be higher than \b By Velocity \b0 value when it was pushed by other dynamic objects. Turned Off when set to 0.\par
\lang9\b\par
By Offset\b0 : \lang1033 Inactive object will be activated if will be pushed from it's original position farther than \b By Offset \b0 value. Turned Off when set to 0.\par
\lang9\b\par
By Damage\b0 : \lang1033 Inactive object will be activated if it's Current Damage will be higher than \lang9\b By Damage\lang1033\b0  value. Turned Off when set to 0.\par
\pard\sl276\slmult1\lang9\b\par
By Activator\b0 : \lang1033 Inactive object will be activated by overlapping with object with \b RayFire Activator \b0 component.\par
\pard\sl276\slmult1\lang9\b\par
By Impact\b0 : \lang1033 Inactive object will be activated when it will be shot by \b RayFire Gun \b0 component.\par
\lang9\b\par
By Connectivity\b0 : \lang1033 Inactive object will be activated if it won't be able to reach any Inactive object with Unyielding property On through other Inactive objects. \b RayFire Connectivity \b0 components has to be used to establish connectivity between Inactive objects and activate them if they loose connection with other Inactive objects.\par
\par
\b Unyielding\b0 : Allows to define Inactive object as Unyielding to activate other Inactive objects with enabled By Connectivity activation type\par
\pard\sl276\slmult1\lang9\b\fs28\tab\par
\fs48\tab Demolition\par
\lang1033\b0\fs22 Demolition can be initiated using method:\par
\cf1\lang9\f1\fs19 public\cf2  \cf1 void\cf2  DemolishObject()\par
\par
\cf0\lang1033\f0\fs22 Slicing by planes can be initiated by method:\par
\pard\box\brdrdash\brdrw0 \sl276\slmult1\cf1\lang9\f1\fs19 public\cf2  \cf1 void\cf2  \lang1033\f2 AddSlicePlane\lang9\f1 (\lang1033\f2 V\cf0\lang9\f1\fs18 ector3[] slicePlane\cf2\fs19 )\par
\lang1033\f2 V\cf0\lang9\f1\fs18 ector3[] slicePlane\lang1033\f2  \f0\fs22 is array with slicing planes info: \par
\pard\sl276\slmult1 (plane position, plane normal, plane position, plane normal, etc...)\lang9\b\fs28\par
\b0\fs44\par
\i Limitations\par
\b\i0\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/ITYShtaF5cQ"}}{\fldrslt{\ul\cf1 https://youtu.be/ITYShtaF5cQ}}}\f0\fs22\par
\par
Solidity\b0 : Local \lang1033 Object solidity multiplier for object. Low Solidity makes object more fragile. Keep in mind that every \b Material Type \b0 in \b Physics \b0 group also has it's own Solidity. Set to 0 if you want object to be demolished at first contact.\lang9\b\par
\par
Depth\b0 : \lang1033 Defines how deep object can be demolished. Depth is limitless if set to 0.\par
\i\tab Example\i0 : \lang9\b Max Depth \lang1033\b0 set to 1, it means that object can be demolished one time and \tab new fragments (Depth level 1 fragments) will not be possible to demolish anymore. \par
\tab If \lang9\b Max Depth \lang1033\b0 set to 2, it means that object can be demolished one time and new \tab fragments (Depth level 1 fragments) will possible to demolish one time, but new \tab fragments (Depth level 2 fragments) will not be possible to demolish anymore. Etc\par
\par
\lang9\b Time\b0 : Safe time. Measures in seconds and a\lang1033 llows to prevent fragments from being demolished right after they were just initialized.\par
\i\tab Example\i0 : \lang9\b Time \lang1033\b0 set to 3 seconds, it means that object can be demolished and \tab new \tab fragments will not be demolished for sure during next 3 seconds.\par
\lang9\b\par
Size\b0 : P\lang1033 revent objects with bounding box size less than defined value to be demolished. Measures in units.\lang9\par
\b\fs32\par
\fs22 Slice by Blade\b0 : \lang1033 Allows object to be sliced by object with \b RayFire Blade \b0 component.\lang9\b\fs32\par
\par
\b0\fs44\par
\i Mesh Demolition\b\i0\fs22\par
\lang1033\b0\fs28\tab\par
\tab\b Fragments\lang9\fs22\par
\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/TpTHstzzvRU"}}{\fldrslt{\ul\cf1 https://youtu.be/TpTHstzzvRU}}}\f0\fs22\par
\par
Amount\b0 : \lang1033 Defines amount of new fragments after demolition.\par
\lang9\b\par
Variation\b0 : \lang1033 Defines additional amount variation for object in percents. Final amount always will be higher than \b Amount \b0 value.\par
\i\tab Example\i0 : Amount set to 50, Variation set to 10 %. Final amount will be randomly picked \tab in range from 50 to 55. \par
\lang9\b\par
Depth Fade\b0 : Amount m\lang1033 ultiplier for next Depth level. Allows to decrease fragments amount of every next demolition level.\par
\i\tab Example\i0 : \b Amount \b0 set to 100. \b Depth Fade \b0 set to 0.5. Object demolishes to 100 \tab fragments. For every fragment it's \b Amount \b0 for next demolition will be set to 50 (100 * \tab 0.5). Let's say some fragment demolishes to 50 fragments. For every fragment among \tab these 50 fragments it's \b Amount \b0 for next demolition will be set to 25 (50 * 0.5). \par
\lang9\b\par
Contact Bias\b0 : Higher value a\lang1033 llows to create more tiny fragments closer to collision contact point and bigger fragments far from it. This is the property which makes player understand that Runtime demolition happened right now and nothing was prefragmented before.\par
\lang9\b\par
Seed\b0 : \lang1033 Defines Seed for fragmentation algorithm. Same Seed will produce same fragments for same object every time.\par
\lang9\b\par
Use Shatter\b0 : \lang1033 Allows to use RayFire Shatter properties for fragmentation. Works only if object has RayFire Shatter component. This is the only way to create other Fragmentation types in runtime because default demolition fragmentation type produce only regular Voronoi fragments.\par
\lang9\fs36\par
\i Advanced Properties\b\fs22\par
\lang1033\b0\i0\par
\fs28\tab\b Collider\par
\par
\lang9\fs22 Collider Type\b0 : \lang1033 Defines Collider type for mesh fragments if they bounding box size is less than \b Size Filter \b0 value. Useful in case you want to apply simple colliders for a lot of small fragments. \par
\lang9\b\par
Size Filter\b0 : \lang1033 Defines Bounding Box size value for Collider Type property. Turned Off if set to 0.\b\fs28\par
\par
\b0\tab\b Mesh Ops\par
\par
\lang9\fs22 Decompose\b0 : \lang1033 Decompose output fragment's mesh to several meshes if they are not connected with each other.\par
\par
\lang9\b Remove Collinear\b0 : \lang1033 Remove collinear vertices on output fragment's mesh.\b\fs28\par
\par
\b0\tab\b Custom Layer\par
\lang9\fs22\par
Layer\b0 : \lang1033 Set custom Layer to fragments.\par
\lang9\b\par
\lang1033\b0\fs28\tab\par
\i\fs36 Runtime Caching\lang9\b\fs22\par
\i0\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/RF-srUHcy0g"}}{\fldrslt{\ul\cf1 https://youtu.be/RF-srUHcy0g}}}\f0\fs22\par
\par
Type\b0 : \lang1033 Defines Runtime Caching type. Disabled by default.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b By Frames\b0 : Cache fragment's meshes over defined amount of frames.\par
\b{\pntext\f5\'B7\tab}By Fragments per Frame\b0 : Cache defined amount of fragment's meshes every frame.\par
\pard\li360\sl276\slmult1\par
\pard\sl276\slmult1\lang9\b Frames\b0 : \lang1033 Defines amount of frames for \b By Frames \b0 type.\par
\par
\lang9\b Fragments\b0 : \lang1033 Defines amount of fragments for \b By Fragments per Frame \b0 type.\par
\par
\lang9\b Skip First Demolition\b0 : \lang1033 Do not demolish object when all meshes were cached and wait for next demolition. Allows to use first Demolition to initiate caching and demolish object only at second demolition.\fs28\par
\par
\par
\i\fs44 Cluster Demolition\lang9\b\i0\fs22\par
\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/fNFG4SGWuQQ"}}{\fldrslt{\ul\cf1 https://youtu.be/fNFG4SGWuQQ}}}\f0\fs22\par
\lang1033\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/ZuHq1OFylnM"}}{\fldrslt{\ul\cf1 https://youtu.be/ZuHq1OFylnM}}}\b0\f0\fs28\par
\par
\b\tab Properties\par
\lang9\fs22\par
Mesh Demolition\b0 : \lang1033 Set Runtime demolition type for extracted fragments.\par
\b\fs28\par
\b0\tab\b Connected Cluster\lang9\fs22\par
\par
Connectivity\b0 : \lang1033 Defines Connectivity algorithm for clusters. \par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b By Bounding Box\b0 : Fast but not accurate. Check for connectivity using object's bound boxes. Can be used with any kind of objects.\par
\b{\pntext\f5\'B7\tab}By Mesh\b0 : Slow but accurate. Check for connectivity using object's mesh. Can be used only with fragments which shares same triangles (Voronoi, Slabs, Splinters and Radial fragmentation types).\par
\pard\sl276\slmult1\lang9\b\par
Contact Radius\b0 : \lang1033 Defines distance from contact point in percentage relative to object's size which will be detached at contact.\par
\lang9\b\fs32\par
\lang1033\b0\i\fs44 Reference Demolition\par
\b\i0\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/CtY4w16357Q"}}{\fldrslt{\ul\cf1 https://youtu.be/CtY4w16357Q}}}\lang9\f0\fs32\par
\par
\fs22\par
\lang1033\b0\fs28\tab\b Source\par
\lang9\fs22\par
Reference\b0 : \lang1033 Defines reference for demolition. Reference will be instantiated and demolished instead of original object.\par
\par
\lang9\b Random List\b0 : \lang1033 Allows to define several references and pick for demolition one random.\par
\b\fs28\par
\b0\tab\b Properties\lang9\fs22\par
\par
Add Rigid\b0 : \lang1033 All references without Rigid Component will get it automatically. Single Object will get Mesh Object Type, Roots with group of mesh objects will get Mesh Root object type.\par
\lang9\b\fs32\par
\par
\b0\i\fs44 Material\par
\b\i0\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/2Aqdzt58xw0"}}{\fldrslt{\ul\cf1 https://youtu.be/2Aqdzt58xw0}}}\f0\fs32\par
\fs22\par
\lang1033\fs28\tab Inner surface\lang9\fs22\par
\par
Inner material\b0 : \lang1033 Defines material for fragment's inner surface. If not applied RayFire will use original object material for inner surface.\par
\lang9\b\par
Mapping Scale\b0 : \lang1033 Defines mapping scale for inner surface. Using this property you can increase or decrease size of texture for inner surface.\par
\b\fs28\tab\par
\tab Outer surface\lang9\fs22\par
\par
Outer material\b0 : \lang1033 Defines material for fragment's.\par
\lang9\b\fs32\par
\par
\b0\i\fs44 Damage\par
\b\i0\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/WfoaziBQiGU"}}{\fldrslt{\ul\cf1 https://youtu.be/WfoaziBQiGU}}}\f0\fs32\par
\fs22\par
Enable\b0 : \lang1033 Allows to demolish object by it's own floating Damage value. Object will be demolished when Current Damage value will be more or equal Max Damage value. Current Damage value can be increased by RayFireBomb and RayFireGun components, by Collision or by public method:\par
\par
\i\f2\fs20\tab\cf1\i0\f1\fs19 public\cf2  \cf1 bool\cf2  ApplyDamage\lang1049\f3 (\cf1 float\cf2  damageValue, Vector3 damagePosition)\fs18\par
\cf0\lang1033\f2\fs22\par
\cf2\i\f0 d\f4 amagePosition\f0 : P\i0 osition in world space. In this case damage position will be used by Contact Bias to create more tiny fragments at damaged area. \par
True boolean return value means than object was demolished because of applied damage.\cf0\lang9\b\par
\par
Max Damage\b0 : \lang1033 Defines maximum allowed damage for object before it will be demolished.\par
\lang9\b\par
Current Damage\b0 : \lang1033 Shows current damage value.\par
\lang9\b\par
\fs28\tab Collisions\fs22\par
\par
Collect Collisions\b0 : \lang1033 Allows to accumulate damage value by collisions during dynamic simulation.\par
\par
\b Multiplier\b0 : Multiply collected collision damage.\par
\lang9\b\fs32\tab\par
\b0\i\fs44 Fading\par
\b\i0\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/wYFPii-pAuY"}}{\fldrslt{\ul\cf1 https://youtu.be/wYFPii-pAuY}}}\f0\fs32\par
\fs22\par
\par
Fade Type\b0 : Fading let you keep your scene clean and optimize dynamic simulation by destroying fragments  or excluding  them from simulation. \par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\lang1033\b None\b0 : Fragments will stay in scene with no limitation and they always will be simulated.\par
\b{\pntext\f5\'B7\tab}Sim Exclude\b0 : Fragments will be simulated for\b  Life Time \b0 period after their birth, then  their Colliders and RigidBody components will be destroyed. \par
\b{\pntext\f5\'B7\tab}Move Down\b0 : Fragments will be simulated for \b Life Time \b0 period after their birth, then they will fall through the ground and will be destroyed after \b Fade Time \b0 period. \par
\b{\pntext\f5\'B7\tab}Scale Down\b0 : Fragments will be simulated for \b Life Time \b0 period after their birth, then they will start slowly scaling to nothing during \b Fade Time \b0 period and destroyed after all.\par
\b{\pntext\f5\'B7\tab}Destroy: \b0 Fragments will be simulated for \b Life Time \b0 period after their birth and destroyed instantly.\par
\pard\sl276\slmult1\par
\lang9\b Size FIlter\b0 : Prevent object for fading if it's size bigger than defined value\lang1033 . Turned Off if 0.\par
\lang9\b\par
Life Time\b0 : Minimum  p\lang1033 eriod of time in seconds during which fragments created by demolition or slicing will be simulated.\par
\par
\lang9\b Life Variation\b0 : \lang1033 Add random period of time in seconds to final \b Life Time.\b0\par
\par
\lang9\b Fade Time\b0 : \lang1033 Period of time in seconds during which object slowly moves through the ground or scales down to nothing.\par
\lang9\fs28\par
\par
\i\fs44 Events\par
\b\i0\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/lRlqcHGA1sI"}}{\fldrslt{\ul\cf1 https://youtu.be/lRlqcHGA1sI}}}\f0\fs32\par
\par
\lang1033\b0\fs22 RayFire Rigid component provides subscription to \b Demolition \b0 and \b Activation \b0 events.\par
\pard\box\brdrdash\brdrw0 \sl276\slmult1\b\par
\b0 Subscription to \b Global \b0 event will invoke subscribed method when any demolition happens.\b\par
\par
Global Demolition \b0 event subscription reference\b : \cf3\b0\f2\fs18  \par
\cf0\b\tab\b0\f1 RFDemolitionEvent.GlobalEvent += \f2 MyMethod\f1 ;\cf4\b\par
\cf0\f0\fs22\par
Global Activation \b0 event subscription reference\b : \cf3\b0\f2\fs18  \par
\cf0\b\tab\b0\f1 RF\f2 Activation\f1 Event.GlobalEvent += \f2 MyMethod\f1 ;\cf4\par
\pard\sl276\slmult1\cf0\lang9\b\f0\fs22\par
\pard\box\brdrdash\brdrw0 \sl276\slmult1\lang1033\b0 Subscription to \b Local \b0 event will invoke subscribed method when demolition of specific Rigid script happens and because of this you need to have reference to Rigid component you want to track. \par
\b\par
Local Demolition \b0 event subscription reference\b : \cf3\b0\f2\fs18  \par
\tab\cf0\f1 GameObject \f2 myGameObject\f1  = GameObject.Find("\f2 MyObjectWithRigidComponent\f1 ");\f2\par
\tab\lang9\f1 RayfireRigid rigid = \lang1033\f2 myGameObject\lang9\f1 .\b GetComponent\b0 <RayfireRigid>();\line\lang1033\f2\tab\lang9\f1 rigid.demolitionEvent.LocalEvent \lang1033\f2 +\lang9\f1 = \lang1033\f2 MyMethod\lang9\f1 ;\cf4\par
\cf0\lang1033\b\f0\fs22\par
Local Activation \b0 event subscription reference\b : \cf3\b0\f2\fs18  \par
\tab\cf0\f1 GameObject \f2 myGameObject\f1  = GameObject.Find("\f2 MyObjectWithRigidComponent\f1 ");\f2\par
\tab\lang9\f1 RayfireRigid rigid = \lang1033\f2 myGameObject\lang9\f1 .\b GetComponent\b0 <RayfireRigid>();\line\lang1033\f2\tab\lang9\f1 rigid.\lang1033\f2 activation\lang9\f1 Event.LocalEvent \lang1033\f2 +\lang9\f1 = \lang1033\f2 MyMethod\lang9\f1 ;\cf4\par
\pard\sl276\slmult1\cf0\b\f0\fs32\par
\pard\box\brdrdash\brdrw0 \sl276\slmult1\lang1033\b0\fs22 Keep in mind that \f2\fs18 MyMethod\f0\fs22  should have RayFireRigid component as input, in this way you can get access to all public variables of Rigid component, for instance:\lang9\f1\fs18\par
\pard\box\brdrdash\brdrw0 \li720\sl276\slmult1 void \lang1033\f2 MyMethod\lang9\f1 (RayfireRigid rigid)\line\b\{\line     \b0 Debug.Log(rigid.\i fragments\i0 .\i Count\i0 );\line\}\cf4\par
\pard\box\brdrdash\brdrw0 \sl276\slmult1\cf0\lang1033\f0\fs22 will show in console amount of fragments which were created as a result of demolition.\cf3\f2\fs18\par
\pard\sl276\slmult1\cf0\lang9\f0\fs28\par
=============================================================\par
\lang1033\fs22\par
\pard\sl276\slmult1\qc\lang9\ul\b\fs52 RayFire Shatter component\fs36\par
\pard\sl276\slmult1\ulnone\fs32\par
\b0\fs22 It's main purpose is \b Prefragmentation \b0 in Editor mode. For now it provides 6 fragmentation types: \b Voronoi\b0 , \b Splinters, Slabs, Radial, Slices\b0  and \b Tetrahedron \b0 based fragmentation.\par
\lang1033\b\fs32{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=QOKCyC4hRho"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=QOKCyC4hRho}}}\f0\fs32\par
\par
\lang9\tab\lang1033\fs48 Fragments \lang9\fs22\par
\par
Fragment Type\lang1033\b0 : Defines fragmentation type for object\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b Voronoi\b0 : Low poly, convex, physics friendly fragments.\par
\b{\pntext\f5\'B7\tab}Splinters\b0 : Low poly, convex, physics friendly fragments, stretched along one axis.\par
\b{\pntext\f5\'B7\tab}Slabs\b0 : Low poly, convex, physics friendly fragments, stretched along two axes.\par
\b{\pntext\f5\'B7\tab}Radial\b0 : Low poly, convex, physics friendly fragments, creates radial fragments pattern.\par
\b{\pntext\f5\'B7\tab}Slice\b0 : Slice object by planes.\par
\b{\pntext\f5\'B7\tab}Tets\b0 : Tetrahedron based fragments, this type is mostly useless as is and should be used with Gluing, in this case it creates high poly concave fragments.\par
\pard\sl276\slmult1\lang9\i\fs44\par
Voronoi\b\i0\fs32\par
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=KuCXYWvnSm4"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=KuCXYWvnSm4}}}\f0\fs32\par
\fs22\par
Amount\lang1033\b0 : Defines amount of points in point cloud, every point represent rough center of  fragment.\par
\par
\b Center Bias\b0 : Defines offset of points in point cloud towards \b Center\b0 . Using high value it is possible to create more tiny fragments closer to \b Center \b0 and less bigger fragments far from it.\par
\par
\lang9\i\fs44\par
Splinters\b\i0\fs32\par
\fs22\par
Amount\lang1033\b0 : Defines amount of points in point cloud, every point represent rough center of  fragment.\par
\par
\lang9\b Strength\lang1033\b0 : Defines sharpness of stretched splinters.\par
\par
\b Center Bias\b0 : Defines offset of points in point cloud towards \b Center\b0 . Using high value it is possible to create more tiny fragments closer to \b Center \b0 and less bigger fragments far from it.\par
\par
\lang9\i\fs44\par
Slabs\b\i0\fs32\par
\fs22\par
Amount\lang1033\b0 : Defines amount of points in point cloud, every point represent rough center of  fragment.\par
\par
\lang9\b Strength\lang1033\b0 : Defines sharpness of stretched slabs.\par
\par
\b Center Bias\b0 : Defines offset of points in point cloud towards \b Center\b0 . Using high value it is possible to create more tiny fragments closer to \b Center \b0 and less bigger fragments far from it.\par
\par
\lang9\b\fs32\tab\par
\b0\i\fs44 Radial\b\i0\fs32\par
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=bn2vhSdPj9g"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=bn2vhSdPj9g}}}\f0\fs32\par
\fs22\par
Radius\lang1033\b0 : Radius of radial fragmentation type.\par
\b\par
Divergence\b0 : Radial type creates point cloud which creates Voronoi fragments. Divergence property defines random offset for points in this point cloud. High divergence provides more chaotic fragments.\par
\lang9\b\par
Restrict\lang1033\b0 : Divergence offset points in all directions. If Restrict property is On points will be restricted to plane.\par
\lang9\b\par
Rings\lang1033\b0 : Defines amount of Rings.\par
\b\par
Focus\b0 : Defines bias to center for rings.\par
\lang9\b\par
Focus Str\lang1033\b0 : Defines Focus bias strength.\par
\lang9\b\par
Random Rings\lang1033\b0 : Add random offset to rings position.\par
\b\par
Rays\b0 : Defines amount of Rays.\par
\lang9\b\par
Random Rays\lang1033\b0 : Add random offset to rings direction.\par
\lang9\b\par
Twist\lang1033\b0 : Add rotation to rings relative to center.\par
\par
\lang9\b\fs32\tab\par
\b0\i\fs44 Slice\b\i0\fs32\par
\fs22\par
Plane\lang1033\b0 : Defines slicing plane by two axes.\par
\b\par
Slice List\b0 : List with transforms for slice planes.\par
\par
\lang9\b\fs32\tab\par
\b0\i\fs44 Tets properties\b\i0\fs32\par
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=8I00u-ivckQ"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=8I00u-ivckQ}}}\f0\fs32\par
\fs22\par
Density\lang1033\b0 : Defines density of tetrahedron cage. \par
\b\par
Noise\b0 : Add noise for tetrahedrons\par
\lang9\b\par
Mult\lang1033\b0 : Multiplier for \b Density\b0 .\par
\par
\fs28\tab\par
\tab\b\fs44 Common Properties\fs32\par
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=KuCXYWvnSm4"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=KuCXYWvnSm4}}}\lang9\f0\fs22\par
\par
Mode\lang1033\b0 : Seed.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\lang9\b Runtime\lang1033\b0 : Seed.\lang9\b\par
{\pntext\f5\'B7\tab}Editor\lang1033\b0 : Seed.\lang9\b\par
\pard\sl276\slmult1\par
Seed\lang1033\b0 : Seed for all random parameters.\lang9\b\par
\par
Decompose\lang1033\b0 : Decompose fragments to several meshes by connectivity of the original mesh.\par
\b\par
Remove Collinear\b0 : Copy.\b\par
\par
Copy Components\b0 : Copy components from fragmented object to fragments.\par
\par
\par
\lang9\i\fs44 Interior\b\i0\fs32\par
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=fMPGXiLJDo0"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=fMPGXiLJDo0}}}\f0\fs32\par
\fs22\par
Inner material\b0 : \lang1033 Allows to define material for fragment's inner surface. If not applied RayFire will use original object material for inner surface.\par
\lang9\b\par
Mapping Scale\b0 : \lang1033 Defines mapping scale for inner surface. Using this property you can increase or decrease size of texture for inner surface.\par
\lang9\fs28\par
\i\fs44 Gluing\b\i0\fs32\par
\fs22\par
Enable\b0 : \lang1033 Allows to glue groups of fragments into single mesh by deleting shared faces.\lang9\b\par
\par
Amount\b0 : \lang1033 Defines total amount of glued groups.\par
\lang9\b\par
Seed\b0 : \lang1033 Seed for random parameters.\lang9\b\par
\par
Relax\b0 : Allows to smooth inner surface.\par
\fs28\par
\par
\lang1033\b\fs44 Editor Mode Properties\fs32\par
\lang9\fs22 Exclude Inner Fragments\b0 : Allows.\par
\fs28\par
===========================================================\par
\par
\ul\b\fs36\par
RayFire Cluster component\par
\lang1033\ulnone\b0\fs22\par
Clusters component can be used to create parent/child hierarchy in Editor mode which can be used for demolition in Play mode. Also clusters allows to simulate dynamic concave objects which is impossible to do for now (2018.3) in Unity with regular rigid bodies.\par
\par
\fs28\tab Properties group\lang9\b\fs22\par
\lang1033\b0\par
\lang9\b Type\lang1033\b0 : Defines clustering algorithm.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1 By Point Cloud: Creates random Vector3 point cloud inside bounding box of all children meshes, and then create clusters based on this point cloud, every child sticks to closest point. This type allows to gather into one cluster objects with meshes which are not connected with each other.\par
{\pntext\f5\'B7\tab}By Shared Area: Creates clusters starting from biggest, not clustered yet mesh and then start add neighbour mesh with biggest shared area, then do it again. This type is good for objects just fragmented using Shatter component. In this way clusters looks more natural.\par
\pard\sl276\slmult1\par
\b Depth\b0 : Defines how deep will go clustering. \par
\b Seed\b0 : Random seed for all random values. \par
\b Smooth Pass\b0 : Higher value smooth clusters and let them switch some fragments among each other to make border between clusters smoother.\par
\par
\fs28\tab By Point Cloud group\lang9\b\fs22\par
\lang1033\b0\par
\b Base Amount\b0 : Maximum amount child clusters. \par
\b Depth Amount\b0 : Amount of shards in child clusters. \par
\par
\lang9\b Connectivity\b0 : \lang1033 Defines Connectivity algorithm for shards. \par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b By Bounding Box\b0 : Fast but not accurate. Check for connectivity using shard's bound boxes. Can be used with any kind of objects.\par
\b{\pntext\f5\'B7\tab}By Mesh\b0 : Slow but accurate. Check for connectivity using shard's mesh. Can be used only with fragments which shares same triangles (Voronoi, Slabs, Splinters and Radial fragmentation types).\par
\pard\sl276\slmult1\par
\fs28\tab By Shared Area group\lang9\b\fs22\par
\lang1033\b0\par
\b Minimum Amount\b0 : Minimum amount of shards in cluster. \par
\b Maximum Amount\b0 : Maximum amount of shards in cluster. \par
\par
\lang9\fs28\par
===========================================================\par
\par
\ul\b\fs36\par
RayFire Activator component\par
\ulnone\b0\fs22\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=LIkdaM1BI8c"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=LIkdaM1BI8c}}}\lang1033\b0\f0\fs22\par
\par
Using Activator component you can activate (turn them to full dynamic objects) Inactive objects. \par
\lang9\b\fs32\par
\b0\fs28\tab Activation group\b\fs32\par
\fs22\par
Type\lang1033\b0 : Defines when Inactive object will be activated.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1 On Enter: Inactive object will be activated when Activator will Enter it's collider.\par
{\pntext\f5\'B7\tab}On Exit:  Inactive object will be activated when Activator will Exit it's collider.\par
\pard\sl276\slmult1\b\par
Delay\b0 : Delay in seconds after which object will be activated.\par
\par
\b\fs28\tab\lang9\b0 Animation group\par
\b\fs22\par
\lang1033 Duration\b0 : Defines position animation duration in seconds.\par
\par
\b Scale Animation\b0 : Allows to animate Scale.\par
\lang9\b\par
Position Animation\lang1033\b0 : Defines the way position will be animated for Activator.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b By Position List\b0 : Activator will use positions which were defined by user manually using Add Position button. \par
\b{\pntext\f5\'B7\tab}By Static Line\b0 : Activator will be animated along Line renderer define for \b Line \b0 variable, if line will be moved during animation Activator will not be affected. \par
\b{\pntext\f5\'B7\tab}By Dynamic Line\b0 : Activator will be animated along Line renderer define for \b Line \b0 variable, if line will be moved during animation Activator will be moved as well.\par
\pard\sl276\slmult1\b\par
Line\b0 : Line Renderer component which will be used for position animation\par
\b\par
Position List\b0 : List of positions defined manually.\par
\par
Animation can be triggered by public method:\par
\cf1\f1\fs19 public\cf2  \cf1 void\cf2  TriggerAnimation()\cf0\f0\fs22\par
\par
stopped by :\par
\cf1\f1\fs19 public\cf2  \cf1 void\cf2  StopAnimation()\par
\cf0\f0\fs22\par
and reset by:\par
\cf1\f1\fs19 public\cf2  \cf1 void\cf2  ResetAnimation()\par
\par
\cf0\lang9\f0\fs28\par
===========================================================\par
\par
\ul\b\fs36\par
RayFire Gun component\par
\lang1033\ulnone\b0\fs22\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=UstoNAaVav4"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=UstoNAaVav4}}}\lang1033\b0\f0\fs22\par
\par
Using Gun component you can shoot objects, demolish them at Impact point, create Impact Flash, Particle Debris and Dust, dynamically push them and activate.\par
\par
Single shot can be initiated by public method:\par
\cf1\f1\fs19 public\cf2  \cf1 void\cf2  Shoot()\cf0\f0\fs22\par
\par
\lang9\fs28\tab Properties group\b\fs32\par
\fs22\par
Axis\lang1033\b0 : Defines local shooting axis of object with Gun component, in case Target is not defined.\par
\par
\lang9\b Max Distance\lang1033\b0 : Maximum distance to shoot.\par
\par
\lang9\b Target\lang1033\b0 : Transform component which will be used as target.\par
\par
\lang9\fs28\tab Burst group\b\fs32\par
\fs22\par
Rounds\lang1033\b0 : Amount of shots during single burst.\par
\par
\lang9\b Rate\lang1033\b0 : Defines delay in seconds until next shot.\par
\par
\lang9\fs28\tab Impact group\b\fs32\par
\fs22\par
Strength\lang1033\b0 : Defines strength of physical push which will get Impact target.\par
\par
\lang9\b Radius\lang1033\b0 : Defines radius in units around Impact point. Turned off when 0, in this case only Impact target will be pushed.\par
\par
\lang9\fs28\tab Damage group\b\fs32\par
\fs22\par
Damage\lang1033\b0 : Defines damage value which will be applied to object with Rigid component.\par
\par
\lang9\fs28\tab Impact particles group\b\fs32\par
\fs22\par
Debris\lang1033\b0 : Create particle debris in case of shot in object with Rigid component. Rigid component has to have Debris\\On Impact property enabled.\par
\par
\lang9\b Dust\lang1033\b0 : Create particle dust in case of shot in object with Rigid component. Rigid component has to have Dust\\On Impact property enabled.\par
\par
\lang9\fs28\tab Impact flash group\b\fs32\par
\fs22\par
Enable Impact Flash\lang1033\b0 : Create object with Light component for a moment at Impact point.\par
\par
\lang9\b Flash Strength\lang1033\b0 : Defines Light's intensity.\par
\par
\lang9\b Flash Range\lang1033\b0 : Defines Light's range.\par
\par
\lang9\b Flash Distance\lang1033\b0 : Defines offset in units from Impact point.\par
\par
\lang9\b Flash Color\lang1033\b0 : Defines Light's color.\par
\par
\lang9\fs28\tab Filters group\b\fs32\par
\fs22\par
Tag\lang1033\b0 : Gun will shoot only objects with picked Tag. You can pick only one Tag.\par
\b\par
Layer\b0 : Gun will shoot only objects with defined layer. You can define several Layers.\par
\par
\par
\lang9\fs28 ===========================================================\par
\ul\b\fs36\par
RayFire Blade component\par
\lang1033\ulnone\b0\fs22\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=wNgXlZS0mTA"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=wNgXlZS0mTA}}}\lang1033\b0\f0\fs22\par
\par
Using Blade component it is possible to slice objects to two pieces in runtime. \par
Object with Blade component also should have Collider (Will be automated in next builds).\par
\lang9\b\par
Cut Type\lang1033\b0 : Defines when target object will be sliced.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b Exit\b0 : Target object will be sliced when \b Blade \b0 collider will \b exit \b0 target collider. Blade will use it's position and plane over axes defined by \b Slice Type \b0 property at \b Exit \b0 frame.\par
\b{\pntext\f5\'B7\tab}Enter\b0 : Target object will be sliced when \b Blade \b0 collider will \b enter \b0 target collider. Blade will use it's position and plane over axes defined by \b Slice Type \b0 property at \b Enter \b0 frame.\par
\b{\pntext\f5\'B7\tab}Enter Exit\b0 : Target object will be sliced when \b Blade \b0 collider will \b exit \b0 target collider. Blade will use average position and plane over axes defined by\b  Slice Type \b0 property at \b Enter and Exit \b0 frames.\par
\pard\li360\sl276\slmult1\par
\pard\sl276\slmult1\lang9\b Slice Type\lang1033\b0 : Defines slicing plane which will be used to slice target object.\par
\pard\li360\sl276\slmult1\b XY\b0 : Plane will lay one X and Y axes. It's normal will point over Z axis.\par
\b XZ\b0 : Plane will lay one X and Z axes. It's normal will point over Y axis.\par
\b YZ\b0 : Plane will lay one Y and Z axes. It's normal will point over X axis.\par
\par
\pard\sl276\slmult1\lang9\fs28\tab Filters group\b\fs32\par
\fs22\par
Tag\lang1033\b0 : Blade will slice only objects with picked Tag. You can pick only one Tag.\par
\b\par
Layer\b0 : Blade will slice only objects with defined layer. You can define several Layers.\par
\pard\li360\sl276\slmult1\par
\pard\sl276\slmult1\par
\lang9\fs28 ===========================================================\par
\par
\ul\b\fs36 RayFire Bomb component\par
\lang1033\ulnone\b0\fs22\par
Bomb explosion can be initiated by public method:\lang9\b\fs32\par
\cf1\b0\f1\fs19 public\cf2  \cf1 void\cf2  Explode (\cf1 float\cf2  Delay = 0)\cf0\b\f0\fs32\par
\lang1033\b0\fs22 Where \cf2\lang9\f1\fs19 Delay\lang1033\f2  \cf0\f0\fs22 is time delay in seconds.\lang9\b\fs32\par
\par
\tab\b0\fs28 Range group\b\fs32\par
\fs22\par
Range Type\lang1033\b0 : Defines explosion direction for objects. For now there is only one type, but later there will be more.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b Spherical\b0 : Explosion expands in all directions from explosion position. \par
\pard\sl276\slmult1\par
\b Fade Type\b0 : Defines how quickly explosion Strength fade out relative to distance from explosion position.\par
\pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl276\slmult1\b Linear\b0 : Strength falloff linearly.\par
\b{\pntext\f5\'B7\tab}Exponential\b0 : Strength falloff exponentially.\par
\b{\pntext\f5\'B7\tab}None\b0 : Strength use maximum value for all objects in range.\par
\pard\sl276\slmult1\lang9\b\par
Range\lang1033\b0 : Explosion ranged in Units, all objects in Range value will be affected by explosion.\par
\par
\lang9\b\fs32\tab\b0\fs28 Impulse group\b\fs32\par
\fs22\par
Strength\lang1033\b0 : Maximum explosion strength at the center of explosion position.\par
\par
\b Variation\b0 : Strength Variation in percents.\par
\par
\lang9\b Chaos\lang1033\b0 : Random spinning strength for objects, high Chaos value makes objects spinning faster at explosion.\par
\par
\b Force By Mass\b0 : Allows to affect with higher Strength to small and light objects and with less Strength to big and Heavy objects.\par
\b\par
Affect Kinematik\b0 : Allows to explode Kinematik objects.\par
\par
\lang9\b\fs32\tab\b0\fs28 Detonation group\b\fs32\par
\fs22\par
Height Offset\lang1033\b0 : Allows to change Explosion position over global Y axis. Useful if you want to make explosion more spectacular and explode objects upper even though your object with Bomb component should explode them parallel to the ground.\par
\par
\b Delay\b0 : Delay in seconds after which Bomb will be exploded. Useful in case you want to trigger explosion via method but you want bomb to explode after some delay.\par
\par
\lang9\b\fs32\tab\b0\fs28 Damage group\b\fs32\par
\fs22\par
Apply Damage\lang1033\b0 : Allows to apply damage to objects with Rigid component and demolish them when Rigid's \b Current damage\b0  value will be more than \b Maximum damage\b0 .\par
\b\par
Damage Value\b0 : Damage which will applied to object with Rigid component.\par
\par
\lang9\fs28\tab Filters group\b\fs32\par
\fs22\par
Tag\lang1033\b0 : Explosion will affect only objects with picked Tag. You can pick only one Tag.\par
\b\par
Layer\b0 : Explosion will affect only objects with defined layer. You can define several Layers.\par
\par
\lang9\fs28\par
===========================================================\par
\par
\ul\b\fs36 RayFire Wind component\par
\ulnone\fs32\par
\tab\b0\fs28 Gizmo group\lang1033\fs22\par
\b\par
Gizmo Size\b0 : Defines size of Wind Gizmo. Wind force can be applied to dynamic objects only inside gizmo.\par
\par
\lang9\b\fs32\tab\b0\fs28 Noise group\lang1033\fs22\par
\lang9\b\par
Global Scale\lang1033\b0 : Defines Global Noise scale. The higher Global Scale make wind more chaotic and dense.\par
\b\par
Length Scale\b0 : Defines Noise scale over Z (Wind direction) axis.\par
\b\par
Width Scale\b0 : Defines Noise scale over X axis.\par
\b\par
Speed\b0 : Defines speed of noise offset over Z (Wind direction) axis.\par
\par
\lang9\b\fs32\tab\b0\fs28 Strength group\b\fs32\par
\fs22\par
Minimum\lang1033\b0 : Minimum strength applied to dynamic object at position where noise strength is 0.\par
\b\par
Maximum\b0 : Maximum strength applied to dynamic object at position where noise strength 1.\par
\b\par
Torque\b0 : Defines rolling torque strength for dynamic objects.\par
\b\par
Force By Mass\b0 : Applies Wind strength to object by their mass.\par
\par
\lang9\b\fs32\tab\b0\fs28 Direction group\b\fs32\par
\fs22\par
Divirgency\lang1033\b0 : Defines angle spread for wind direction\par
\b\par
Turbulence\b0 : Defines how quickly \b Divergency \b0 is changing.\par
\par
\lang9\b\fs32\tab\b0\fs28 Preview group\lang1033\fs22\par
\b\par
Preview Density\b0 : Defines amount of Strength and Direction preview helpers.\par
\b\par
Preview Size\b0 : Defines size of Strength and Direction preview helpers.\par
\par
\par
\lang9\fs28\tab Filters group\b\fs32\par
\fs22\par
Tag\lang1033\b0 : Wind will affect only objects with picked Tag. You can pick only one Tag.\par
\b\par
Layer\b0 : Wind will affect only objects with defined layer. You can define several Layers.\par
\lang9\b\fs32\tab\lang1033\b0\fs22\par
\lang9\fs28\par
===========================================================\par
\par
\ul\b\fs36 RayFire Vortex component\par
\ulnone\fs32\par
\tab\b0\fs28 Anchor points group\lang1033\fs22\par
\b\par
Top Anchor\b0 : Position of Top anchor point.\par
\b Bottom Anchor\b0 : Position of Bottom anchor point.\par
\lang9\b\fs32\par
\tab\b0\fs28 Gizmo group\par
\lang1033\fs22\par
\b Top Radius\b0 : Radius in Units for Top anchor.\par
\b Bottom Radius\b0 : Radius in Units for Bottom anchor.\par
\par
\lang9\fs28\tab Eye group\lang1033\b\par
\fs22\par
Eye\b0 : Size of inner eye hole in percents to radius.\par
\lang9\fs28\par
\b\fs32\tab\b0\fs28 Strength group\par
\lang1033\fs22\par
\b Force By Mass\b0 : Applies Swirl strength by object's mass.\par
\b Stiffness\b0 : Defines how hard object will try to reach it's local position inside Vortex.\par
\b Swirl Strength\b0 : Defines swirl animation speed.\par
\par
\lang9\b\fs32\tab\b0\fs28 Torque group\lang1033\par
\b\fs22\par
Enable Torque\b0 : Enables object spinning around it's center of mass. \par
\b Torque Strength\b0 : Defines spinning speed.\par
\b Torque Variation\b0 : Defines \b Torque Strength \b0 variation.\par
\par
\lang9\b\fs32\tab\b0\fs28 Height bias group\lang1033\par
\b\fs22\par
Enable height Bias\b0  Enables object height animation inside Vortex.\par
\b Bias Speed\b0 : Defines height animation speed.\par
\b Bias Spread\b0 : Defines how far object will be animated from it's default position.\par
\lang9\fs28\par
\b\fs32\tab\b0\fs28 Seed group\lang1033\par
\b\fs22\par
Seed\b0 : Random seed for all random values. Affects on object's position in vortex, Swirl and Torque strength, etc.\lang9\fs28\par
\par
\b\fs32\tab\b0\fs28 Preview group\lang1033\fs22\par
\par
\b Circles\b0 : Defines amount of gizmo preview circles for Vortex\par
\par
\lang9\fs28\tab Filters group\b\fs32\par
\fs22\par
Tag\lang1033\b0 : Vortex will affect only objects with picked Tag. You can pick only one Tag.\par
\b\par
Layer\b0 : Vortex will affect only objects with defined layer. You can define several Layers.\par
\par
\lang9\fs28\par
===========================================================\par
\ul\b\fs36\par
RayFire Recorder component\par
\ulnone\fs32\par
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=5DaVEKn4raA"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=5DaVEKn4raA}}}\f0\fs32\par
\par
\tab\b0\fs28 Record properties group\lang1033\fs22\par
\b\par
Record On Start\b0 : Start recording on start. Otherwise recording can be started by "Start recording" button\par
\par
\b Clip Name\b0 : Animation clip asset name.\par
\par
\b Duration\b0 : Time in seconds. Recording can be stopped by "Stop record" button\par
\par
\b Rate\b0 : Defines amount of keys per second.\par
\par
\b Reduce keys\b0 : Remove keys with the same value as it's neighbour.\par
\par
\b Threshold\b0 : Remove keys by threshold value.\par
\par
\lang9\fs28\tab\par
\tab Playback properties group\lang1033\fs22\par
\par
\b Play On Start\b0 : Start playing animation on start. Otherwise playback can be started by "Start play" button\par
\par
\b Animation Clip\b0 : Animation clip which will be played. \par
IMPORTANT: Animation clip should be defined in controller.\par
\par
\b Controller\b0 : Controller with animation clip which should be played.\par
\par
\par
\lang9\fs28\tab Rigid Playback group\lang1033\fs22\par
\par
\b Set to kinematic\b0 : Set all children's Rigid components simulation type to Kinematic.\par
\lang9\fs28\par
\par
===========================================================\par
\ul\b\fs36\par
RayFire Snapshot component\par
\par
\ulnone\fs32{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=MDMwzzLndXQ"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=MDMwzzLndXQ}}}\ul\f0\fs36\par
\ulnone\fs32\par
\tab\b0\fs28 Save properties group\lang1033\fs22\par
\b\par
Asset name\b0 : Asset file name.\par
\par
\b Compress\b0 : Reduce asset size twice when On.\par
\par
\lang9\fs28\tab Load properties group\lang1033\fs22\par
\b\par
Snapshot Asset\b0 : Asset file which will be loaded.\par
\par
\b Size filter\b0 : Size filter to exclude loaded objects by size.\par
\par
\lang9\b\fs52\par
}
 